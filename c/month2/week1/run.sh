#!/bin/bash

if [ -e *.out ]; then
    rm *.out
fi

# 1.编写一个顺序表的操作代码（数组：int arr[10]）
# scanf输入一个正数n，写入n到数组中
# 负数-n，将对应的n删除。
# 每次输入操作后，将数组中的元素打印出来。（不打印0）
# 6	7	8	0	0	0	0	0	0	0
# 打印678
# 当输入-7时，打印 68
# （写入时需判断是否已满、删除时判断是否已空
# c_name="d1t1"
# （写入时需判断是否已满、删除时判断是否已空
# c_name="d1t2"
# （写入时需判断是否已满、删除时判断是否已空
# c_name="d1t3"
# 读取目录下的所有文件ebm,并可以滑动切换, 电子相册。点击屏幕左边上一张点击屏幕右边下一张
# c_name="d2t1"
# 递归读取目录下的指定文件
# c_name="d2t2"
# 编写一个顺序表的操作代码
# c_name="d3t1"
# 递归读取目录下的指定文件,读取目录下的所有文件ebm,并可以滑动切换, 电子相册。左划上一张右划下一张
# c_name="d3t2"

# 单向链表1 添加节点在链尾,添加节点在头部,//删除节点 //打印链表
# c_name="d3t3"
# 建立一个包含若干整数的单向链表，然后通过某些算法，将其中的数据翻转。（单向链表）
# c_name="d3t4"
# 单向循环链表
# c_name="d3t5"
# 单向循环链表
# c_name="d4t1"
# 双向循环链表
# c_name="d4t2"
# 约瑟夫环问题。（单向循环链表)
# c_name="d4t3"
# 用链表存储若干自然数。比如输入一个整数10后：（双向循环链表）
# c_name="d4t4"
# 用链表存储若干自然数。比如输入一个整数10后：（双向循环链表）
# c_name="d5t1"
# # 约瑟夫环问题。（单向循环链表) 第二种思路
# c_name="d5t2"
# # 约瑟夫环问题。（单向循环链表) 第二种思路
# c_name="d5t3"
# 
# c_name="d5t4"
# 1.把内核链表其他需要的功能函数也完成。
# c_name="d5t5"
# 使用内核链表，重做实验1中的第1
# c_name="d5t6"
# 使用内核链表，重做实验1中的第4
# c_name="d5t7"
# 使用内核链表，重做实验1中的第4
# c_name="d6t1"
# 使用内核链表，重做实验1中的第4
# c_name="d6t2"
# 冒泡排序 链表
# c_name="d6t3"
# 冒泡排序
# c_name="d6t4"
# 插入排序 数组实现
# c_name="d6t5"
# 插入排序,改
c_name="d1t1"


if [ $1 == "x86" ]; then
    # x86_64平台的gcc编译
    gcc $c_name.c -o $c_name.out -Wall
elif [ $1 == "arm" ]; then
    arm-linux-gcc $c_name.c -o $c_name.out -Wall
fi

# * 用arm-linux-gcc交叉编译生成的是arm平台的linux系统执行文件
if [ -e $c_name.out ] && [ -x $c_name.out ]; then

    if [ $2 ]; then
        ./$c_name.out $2
    else
        ./$c_name.out
    fi

else
    echo "编译没有成功,执行文件没有生成"
fi
