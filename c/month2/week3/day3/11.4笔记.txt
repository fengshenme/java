一、信号。
1、在linux下，有哪些信号呢？
ubuntu@ubuntu:~$ kill -l    (-l:list)
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP

例如：19) SIGSTOP

19       -> 信号值
SIGSTOP  -> 信号的名字

2、其实信号的名字与信号值是等价的，他们都是一个宏定义。
被定义在一个头文件中：/usr/include/asm-generic/signal.h
#define SIGHUP     1
#define SIGINT	   2
#define SIGQUIT	   3
#define SIGILL	   4

二、常用信号？
19) SIGSTOP    --> 暂停信号
18) SIGCONT    --> 继续信号
9) SIGKILL     --> 停止信号
2) SIGINT      --> "ctrl + c"
10) SIGUSR1    --> linux提供给用户使用两个信号，没有默认动作
12) SIGUSR2

三、在linux下，这些信号是由谁发出来的？
1、由系统发出来。
14) SIGALRM    --> 当程序中调用alarm()函数时，如果到点了，系统就会自动发出alarm这个信号。
17) SIGCHLD    --> 当子进程退出时，会自动发出这个信号给父进程。

2、由用户主动发出。
如果由用户主动发出，就要学习kill/killall这两个命令。

1）通过kill命令来发送。
kill命令： 给进程PID号发送。

第一步： 先查看进程对应的PID号。
ubuntu@ubuntu:~$ ps -ef
ubuntu     3845   3129 98 17:31 pts/7    00:00:04 ./aaaa    -> 目标的PID号是3845

第二步： 通过kill命令来发送。
ubuntu@ubuntu:~$ kill -9 3845
ubuntu@ubuntu:~$ kill -SIGKILL 3845   (两种办法都可以)

2）通过killall命令来发送。
killall命令： 给进程的名字发送。
ubuntu@ubuntu:~$ killall -9 aaaa  （只要进程的名字叫aaaa，都会收到这个信号）


四、关于信号的函数接口。
1、如何发送一个信号给进程？   --->  kill()  ---  man 2 kill

   #include <sys/types.h>
   #include <signal.h>

   int kill(pid_t pid, int sig);

参数：
	pid： 需要发送信号的目标进程的PID号。  
	sig： 需要发送的信号值。

返回值：
	成功：0
	失败：-1

例如：
kill(1000,SIGUSR1);

2、 如何捕捉信号？  ---  signal()  --  man 2 signal

   #include <signal.h>

   typedef void (*sighandler_t)(int);
//给函数指针类型void (*)(int)取了一个新的别名，叫sighandler_t

   sighandler_t signal(int signum, sighandler_t handler);

参数：
	signum：  需要捕捉的信号值
	handler： 信号处理函数。(将来收到信号之后调用的函数)   -> 函数必须长这个样子： void fun(int sig)

返回值：
	成功： 第二个参数的值
	失败： SIG_ERR

#define SIG_ERR -1

例如：
void fun(int sig)  //sig就是捕捉的信号值
{
	//在这里: sig = SIGUSR1
}

signal(SIGUSR1,fun);

3、 挂起一个进程。  ---  pause()  --- man 2 pause
函数功能：  wait for signal
	//等待一个信号的到达，只要信号到达了，进程就会继续运行代码。

      #include <unistd.h>

      int pause(void);

返回值：
	成功： 收到一个正常信号
	失败： 强制被杀死


   案例1：  写一个程序，让父进程发送一个SIGUSR1信号给子进程，子进程收到该信号后，就输出一个字符串。

#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>


void my_fun(int sig)  //sig: 就是捕捉到的信号
{
	printf("catch sig:%d\n",sig);
}

int main()
{
	//1. 先产生一个子进程
	pid_t x;
	x = fork();
	if(x > 0)   //父进程负责发送信号
	{
		printf("parent sleep....\n");
		sleep(5);

		//5. 父进程发送一个信号给子进程
		kill(x,SIGUSR1);
		printf("I send signal to child!\n");

		//6. 回收资源
		wait(NULL);

		//7. 父进程退出
		exit(0);
	}

	if(x == 0)  //子进程负责捕捉信号
	{ 
		//2. 子进程捕捉信号
		signal(SIGUSR1,my_fun);

		//3. 原地等待信号的到达
		pause();

		//4. 子进程就可以退出
		exit(0);
	}

	return 0;
}

五、信号集概念。
1、 什么是信号集？
在linux下，有非常多信号，我们可以根据我们意愿将一些信号加入到一个集合中，那么这个集合就是信号集。
我们可以设置阻塞属性给信号集，那么这个信号集中的所有信号，都会变成阻塞。

2、信号响应、信号阻塞、信号忽略的区别？
信号响应： 收到信号之后，会响应信号的动作。
信号忽略： 收到信号之后，直接丢弃这个信号。
信号阻塞： 如果进程对某一个信号是阻塞，如果又收到这个信号，不会马上响应，而是会把这个信号存放在挂起队列中，将来对信号解除阻塞后，就可以响应挂起队列上的信号。

六、学习关于信号集函数接口？
1、 信号集定义。
信号集其实就是一个变量，数据类型： sigset_t
定义信号集： sigset_t set;

2、 清空信号集。  ---  sigemptyset()  ---  man 3 sigemptyset

    #include <signal.h>

  int sigemptyset(sigset_t *set);

参数：
	set： 需要清空的信号集的地址。

返回值：
	成功: 0
	失败: -1

3、将linux下所有的信号都加入信号集中。  --->  sigfillset()  ---  man 3 sigfillset

   #include <signal.h>

   int sigfillset(sigset_t *set);

参数：
	set： 需要加入全部信号的信号集的地址。

返回值：
	成功: 0
	失败: -1

4、将某一个信号加入到信号集中。  ----  sigaddset()  ---  man 3 sigaddset

    #include <signal.h>

   int sigaddset(sigset_t *set, int signum);

参数：
	set：   需要加入信号的信号集的地址。
	signum: 需要加入的信号的信号值。


返回值：
	成功: 0
	失败: -1

5、从信号集中删除一个信号。  ---  sigdelset()  ---  man 3 sigdelset

    #include <signal.h>

   int sigdelset(sigset_t *set, int signum);

参数：
	set：   需要删除信号的信号集的地址。
	signum: 需要删除的信号的信号值。


返回值：
	成功: 0
	失败: -1


6、判断某一个信号在不在集合中。  ---  sigismember()  ---  man 3 sigismember

    #include <signal.h>

   int sigismember(const sigset_t *set, int signum);

参数：
	set：   需要判断信号的信号集的地址。
	signum: 需要判断的信号的信号值。

返回值：
	成功：  在集合中: 1
		不在集合中：0
	失败：  -1

   练习1： 定义一个信号集，然后清空，再将SIGUSR1加入到集合中，判断这个信号在不在集合中，如果在，就删除掉，再判断在不在集合中。

#include <signal.h>
#include <stdio.h>

int main()
{
	//1. 定义一个信号集合。
	sigset_t set;

	//2. 清空集合。
	sigemptyset(&set);

	//3. 再将SIGUSR1加入到集合中。
	sigaddset(&set,SIGUSR1);

	//4. 判断这个信号在不在集合中
	int ret;
	ret = sigismember(&set,SIGUSR1);
	if(ret == 1)
	{
		printf("SIGUSR1在集合中!\n");
		//5. 如果在，就删除该信号。
		sigdelset(&set,SIGUSR1);
		ret = sigismember(&set,SIGUSR1);
		if(ret == 1)
		{
			printf("SIGUSR1在集合中!\n");
		}
		else if(ret == 0)
		{
			printf("SIGUSR1不在集合中!\n");
		}
		else{
			printf("sigismember error!\n");
		}
	}
	else if(ret == 0)
	{
		printf("SIGUSR1不在集合中!\n");
	}
	else{
		printf("sigismember error!\n");
	}

	return 0;
}

七、如何给信号集设置阻塞的状态？   --> sigprocmask()  ---  man 2 sigprocmask

     #include <signal.h>

    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

参数：
	how：
		SIG_BLOCK   -> 设置阻塞的状态
		SIG_UNBLOCK -> 设置解除阻塞的状态

	set：   需要设置阻塞属性的信号集的地址
	oldset：保留信号集之前的状态，如果不关心，则填NULL。

返回值：
	成功：0
	失败：-1

例如：
sigset set;
sigaddset(&set,SIGUSR1);

sigprocmask(SIG_BLOCK,&set,NULL);  --> 设置阻塞
.....
.....
.....  -> 都是阻塞的。
.....
sigprocmask(SIG_UNBLOCK,&set,NULL);  --> 设置解除阻塞
.....
....
.....  -> 都不是阻塞的。


   案例2： 先让进程产生一个子进程，父进程将SIGUSR1加入到信号集中，再设置信号集为阻塞状态，该状态持续10S（那么在10S内，父进程对SIGUSR1都是阻塞的），10S后，解除阻塞，看看会不会响应这个信号？子进程在10S内发送一个SIGUSR1信号给父进程。


#include <signal.h>
#include <stdio.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>

void my_fun(int sig)
{
	printf("catch sig = %d\n",sig);
}

int main()
{
	//1. 先产生一个子进程
	pid_t x;
	x = fork();
	if(x > 0)  //父进程
	{
		//2. 捕捉信号
		signal(SIGUSR1,my_fun);

		//3. 定义一个信号集，并将SIGUSR1加入到信号集中
		sigset_t set;
		sigemptyset(&set);
		sigaddset(&set,SIGUSR1);

		//4. 给信号集设置阻塞状态
		sigprocmask(SIG_BLOCK,&set,NULL);

		//5. 持续10S
		int i;
		for(i=10;i>0;i--)
		{
			sleep(1);
			printf("block time:%d\n",i);  //小孩的发送过来信号会放在挂起队列上。
		}

		//6. 解除阻塞
		sigprocmask(SIG_UNBLOCK,&set,NULL);

		//7. 回收资源
		wait(NULL);

		exit(0);
	}

	if(x == 0) //子进程
	{
		sleep(3);  //确保父进程先捕捉
		kill(getppid(),SIGUSR1);
		printf("I send signal to parent!\n");
		exit(0);
	}

	return 0;
}











































