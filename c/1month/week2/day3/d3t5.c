#include <stdio.h>

int main(int argc, char const *argv[])
{
    // 题11
    int a[][3] = {{1, 2, 3}, {4, 5, 0}}, (*pa)[3], i;
    pa = a;
    for (i = 0; i < 3; i++) // {{1, 2, 3},{3, 4, 1}}
        if (i < 2)
            pa[1][i] = pa[1][i] - 1; // pa[1][0] = pa[1][0]-1
        else
            pa[1][i] = 1;
    printf("%d\n", a[0][1] + a[1][1] + a[1][2]); // 2 4 1
    // 题12
    /**
     * 就是我使用的是64位的系统，但是在调试时显示的地址为48位，如下图。通过查阅资料，可以知道：地址为48位是表象，
     * 出现这样结果的原因是x86_64处理器硬件限制。因为x86_64处理器地址线只有48条，故而导致硬件要求传入的地址48位到63位地址必须相同，若表示为16进制，则前4位为ffff或者是0000。也就是说有两段合法的地址空间：
        0x00000000 0000 0000-0x0000 7fff ffff ffff
        0xffff8000 0000 0000-0xffff ffff ffff ffff
        由上可知，可表示的地址空间为2^48Byte=2^8TB=256TB,这就是当前处理器的寻址能力，又因为操作系统一般使用地段地址，故而一般只用到第一段地址空间，
        如果要用到第二段地址空间，则需要内存达到寻址空间的一般128TB。根据以上分析，下图即可知：0x7fff ffff da20完整的地址其实是0x0000 7fff ffff da20,为64位。
     * 
    */
    int c[4][5] = {{1, 3, 5, 7, 8}, {2, 4, 6, 8, 9}, {11, 22, 33, 44, 55}, {66, 77, 88, 99, 36}}, (*p)[5];
    p = c;
    printf("%p \n", p[0]);
    printf("%d \n", *p[0]);
    printf("%d \n", *(p + 2)[0]);
    printf("%d \n", *(p+3)[0]);
    printf("%p \n", *(p+1)+3);
    printf("%d \n", *(p[0]+2));

    return 0;
}
