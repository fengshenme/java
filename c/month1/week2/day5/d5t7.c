/*
题1 哪一存储类的变量在包含他们的程序运行时期内一直存在？
    -静态存储类。
哪一存储类的变量可以在多个文件中使用？
    -外部链接的静态存储变量
哪一存储类的变量只限于在一个文件中使用？
    - 内部链接的静态存储变量。

题2、 代码块作用域变量具有哪种链接类型？
    - 空链接。

题3、 说出 C 程序中所有不同的存储类变量在内存中的详细分布情况。

栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。
堆区（heap）：
全局区（静态区static）：
        存放全局变量、静态数据、常量。全局区分为已初始化全局区（data）和未初始化全局区（bss）。
        静态数据段（已初始化）
        （特点：生命周期与进程相当）
        A.全局变量（函数外部定义的变量）
        B.static修饰的变量（局部、全局）
        静态数据段（未初始化）


常量区（.rodata）：存放字符常量，整形常量，字符串常量，
代码区：存放函数体（类成员函数和全局区）的二进制代码。

三种内存分配方式
从静态存储区分配

内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

在栈上创建

在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。

从堆上分配

亦称为动态内存分配。
程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

*/

// 4、 编写一个函数，它返回函数自身被调用的次数，并在一个循环中测试之
#include <stdio.h>

int max_value();

void get_memory(char **p);

void Test(void);


static int count = 0;

int main(int argc, char const *argv[])
{
    int a;
    for (size_t i = 0; i < 5; i++)
    {
        a = max_value();
    }
    printf("%d\n", a);
    printf("%d\n", count);
    Test();
    return 0;
}

int max_value(void)
{
    return ++count;
}

// 5、分析以下代码的输出结果并解释原因。
void get_memory(char **p)
{
    *p = "hello world";
}
void Test(void)
{
    char *str = NULL;
    get_memory(&str);   
    printf("%s\n", str);// hello world
    printf("%p\n", str);//  0x560d2d458008
    printf("%c\n", *(str+1));// e
    printf("%c\n", *str);// h
    printf("%p\n", &str[0]);// 0x560d2d458008
}